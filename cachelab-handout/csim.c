/* csim.c - Aleksander Bapst (abapst)
 *
 * Description:
 *   Program to simulate a cache memory. Takes a text trace generated by
 *   valgrind as input and prints the number of hits/misses/evictions as
 *   output.
 * Example usage:
 *   ./csim -s 4 -E 1 -b 4 -t traces/yi.trace
 *
 * Arguments:
 *   -s: number of set bits
 *   -E: associativity (number of lines)
 *   -b: number of block bits
 *   -t: path to text file input
 */

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <unistd.h>
#include <math.h>

#include "cachelab.h"

typedef unsigned long long mem_addr; // 64-bit type for cache addresses

typedef struct {
// struct containing cache parameters
  int s;
  int b;
  int num_lines;
  int num_sets;
  int vflag;
  int time; // will be incremented with each cache request
  int meh_code; // this 3-bit code will act as a flag for verbose printing

  int hits;
  int misses;
  int evicts;
} cache_params;

typedef struct {
// struct defining a single line
  int timestamp; // this is used for LRU eviction rule
  int valid; // valid bit
  mem_addr tag; // cache memory tag
  char* block; // data block
} line;

typedef struct {
// struct defining a set as a pointer to a number of lines
  line *lines;
} set;

typedef struct {
// struct defining a cache as a pointer to  a number of sets
  set *sets;
} cache;

cache build_cache(cache_params p){
/* Description:
 *   Allocates a nested structure that simulates a cache.
 * Input:
 *   cache_params p: a struct containing parameters needed to build the cache.
 *     int p.num_lines: associativity
 *     int p.num_sets: number of sets
 * Output:
 *   cache sim_cache: cache structure generated by malloc
 */
  cache sim_cache;
  set sim_set;
  line sim_line;
  
  sim_cache.sets = (set*) malloc(sizeof(set) * p.num_sets);
  for (int i = 0; i < p.num_sets; i++){
    sim_set.lines = (line*) malloc(sizeof(line) * p.num_lines);
    sim_cache.sets[i] = sim_set; 
    for (int j = 0; j < p.num_lines; j++){
      sim_line.timestamp = 0;
      sim_line.valid = 0;
      sim_line.tag = 0;
      sim_set.lines[j] = sim_line; 
    } 
  }
  return sim_cache;
}

void free_cache(cache sim_cache, cache_params p){
/* Description:
 *   frees the memory allocated to the simulated cache after simulation is done
 */
  for (int i = 0; i < p.num_sets; i++){
    set sim_set = sim_cache.sets[i];
    if (sim_set.lines != NULL) {
      free(sim_set.lines);
    }
  }
  if (sim_cache.sets != NULL){
    free(sim_cache.sets);
  }
}

cache_params cache_op(cache sim_cache, mem_addr t_address, cache_params p){ 
/* Description:
 *   Simulates a cache memory request, given the current state of the cache,
 *   the cache address for the operation, and the struct of cache parameters.
 *   Least recently used (LRU) line eviction is implemented using a timestamp
 *   field in each line struct,which is updated whenever a block is read or
 *   written to.
 * Inputs:
 *   cache sim_cache: a simulated cache structure allocated in memory.
 *   mem_addr t_address: the cache memory address for the given request.
 *   cache_params p: a structure containing the most recent simulation params.
 * Outputs:
 *   cache_params p: the updated cache params structure
 */
  int empty_index;
  int empty_flag = 0;
  int tag_size = 64-p.s-p.b;
  mem_addr temp = t_address << tag_size; 
  mem_addr set_index = temp >> (tag_size + p.b);
  set query_set = sim_cache.sets[set_index];
  int min_time = query_set.lines[0].timestamp;
  int min_index = 0; // index of LRU line

  mem_addr query_tag = t_address >> (p.s + p.b);

  for (int i = 0; i < p.num_lines; i++){
    line query_line = query_set.lines[i];

    // find the LRU line while we are searching for hits
    if (query_line.timestamp < min_time) {
      min_time = query_line.timestamp;
      min_index = i;
    } 

    // Case 1: data in cache (hit)
    if (query_line.valid && (query_line.tag == query_tag)) {
      query_line.timestamp = p.time;
      p.hits++; 
      p.meh_code += 1; // set first bit to 1
      query_set.lines[i] = query_line; 
      return p;
    } else if (!query_line.valid) {
      empty_flag = 1;
      empty_index = i; // index of an empty line
    }
  }

  // Case 2: Miss found, no eviction needed
  p.misses++;
  p.meh_code += 4; // set third bit to 1
  if (empty_flag) {
    query_set.lines[empty_index].tag = query_tag;
    query_set.lines[empty_index].valid = 1;
    query_set.lines[empty_index].timestamp = p.time; 
    return p; 
  }

  // Case 3: Miss found, eviction needed
  p.evicts++;
  p.meh_code += 2; // set second bit to 1
  query_set.lines[min_index].tag = query_tag;
  query_set.lines[min_index].valid = 1;
  query_set.lines[min_index].timestamp = p.time;
  return p;
}

void print_help(){
/* Description:
 *   prints help/usage message
 */
  fprintf(stderr, "Usage: ./csim-ref [-hv] " 
          "-s <num> -E <num> -b <num> -t <file>\n");
  fprintf(stderr, "Options:\n");
  fprintf(stderr, "  -h         Print this help message.\n");
  fprintf(stderr, "  -v         Optional verbose flag.\n");
  fprintf(stderr, "  -s <num>   Number of set index bits.\n");
  fprintf(stderr, "  -E <num>   Number of lines per set.\n");
  fprintf(stderr, "  -b <num>   Number of block offset bits.\n");
  fprintf(stderr, "  -t <file>  Trace file.\n\n");
  fprintf(stderr, "Examples:\n");
  fprintf(stderr, "  linux>  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n");
  fprintf(stderr, "  linux> "
          "./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n");
}

void print_verbose(char t_type, mem_addr t_address, int t_size, int meh_code){
/* Description:
 *   handles verbose printing of miss/eviction/hit for each trace line
 * Input:
 *   char t_type: trace line type (I, M, L, or S)
 *   mem_addr t_address: 64-bit line address
 *   int t_size: number of words to read
 *   int meh_code: a 3-bit code that is used to print the MEH messages.
 *     example: 101 prints "Miss Hit"
 */
  if (t_type == 'I') {
    return;
  }
  printf("%c %llx,%d", t_type, t_address, t_size); 
  if ((meh_code >> 2) & 1){
    printf(" miss"); 
  }
  if ((meh_code >> 1) & 1){
    printf(" eviction"); 
  }
  if (meh_code & 1){
    printf(" hit"); 
  }
  printf("\n");
}

int main( int argc, char** argv ){
/* Description:
 *   Main function uses getopt to read input arguments and builds the simulated
 *   cache. The specified trace file is opened and read line by line. Each line
 *   is then operated on by the cache simulator and the updated results stored
 *   in the cache param structure p. At the end, the final tally of misses,
 *   hits, and evictions is printed.
 */
  int opt;
  cache_params p;
  p.s = 0;
  p.b = 0;
  p.num_lines = 0;
  p.vflag = 0;
  p.time = 0;
  p.hits = 0;
  p.misses = 0;
  p.evicts = 0;
  char *filename;

  // memory trace parameters
  char t_type;
  mem_addr t_address;
  int t_size;

  while(-1 != (opt = getopt(argc, argv, "s:E:b:t:vh"))){
    switch(opt){
      case 's':
        p.s = atoi(optarg);
        p.num_sets = 1<<p.s;
        break;
      case 'E':
        p.num_lines = atoi(optarg);
        break;
      case 'b':
        p.b = atoi(optarg);
        break;
      case 't':
        filename = optarg;
        break;
      case 'v':
        p.vflag = 1;
        break;
      case 'h':
        print_help();
        exit(0);
      default:
        print_help();
        exit(0);
    }
  } 

  if (p.s == 0 || p.num_lines == 0 || p.b == 0 || filename == NULL){
    fprintf(stderr, "Missing required command line argument\n"); 
    print_help();
    exit(0);    
  }

  cache sim_cache = build_cache(p); // allocate simulated cache 
  FILE *stream = fopen(filename, "r"); // open stream

  if (stream != NULL){
    while (fscanf(stream, " %c %llx,%d", &t_type, &t_address, &t_size) == 3){
      p.meh_code = 0;
      p.time++;
      switch(t_type){
        case 'I':
          break;
        case 'L':
          p = cache_op(sim_cache, t_address, p); // load 
          break;
        case 'S':
          p = cache_op(sim_cache, t_address, p); // store
          break;
        case 'M':
          p = cache_op(sim_cache, t_address, p); // load
          p.time++;
          p = cache_op(sim_cache, t_address, p); // store 
          break;
      }
      if (p.vflag) {
        print_verbose(t_type, t_address, t_size, p.meh_code);
      }
    }
  }

  fclose(stream); // close stream
  printSummary(p.hits, p.misses, p.evicts);
  free_cache(sim_cache, p);
  
  return 0;
}
